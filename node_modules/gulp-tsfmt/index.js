var gutil = require("gulp-util");
var path = require("path");
var through = require("through2");
var ts = require("typescript");
var PLUGIN_NAME = "gulp-tsfmt";
var DEFAULTS = {
    options: {
        IndentSize: 4,
        TabSize: 4,
        NewLineCharacter: "\r\n",
        ConvertTabsToSpaces: true,
        InsertSpaceAfterCommaDelimiter: true,
        InsertSpaceAfterSemicolonInForStatements: true,
        InsertSpaceBeforeAndAfterBinaryOperators: true,
        InsertSpaceAfterKeywordsInControlFlowStatements: true,
        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: false,
        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,
        PlaceOpenBraceOnNewLineForFunctions: false,
        PlaceOpenBraceOnNewLineForControlBlocks: false
    },
    target: "ES5"
};
var Transformer = (function () {
    function Transformer(options, target) {
        this._formatter = ts.formatting;
        this._options = options;
        this._rulesProvider = new this._formatter.RulesProvider();
        this._rulesProvider.ensureUpToDate(this._options);
        this._target = target;
    }
    Transformer.prototype.process = function (file) {
        var source = this._toSourceFile(file);
        var edits = this._formatSource(source);
        file.contents = this._applyEdits(file, edits);
    };
    Transformer.prototype._toSourceFile = function (file) {
        return ts.createSourceFile(path.basename(file.path), file.contents.toString(), this._target);
    };
    Transformer.prototype._formatSource = function (source) {
        return this._formatter.formatDocument(source, this._rulesProvider, this._options);
    };
    Transformer.prototype._applyEdits = function (file, edits) {
        var reduce = function (contents, edit) {
            var head = contents.slice(0, edit.span.start);
            var tail = contents.slice(edit.span.start + edit.span.length);
            var change = new Buffer(edit.newText, "utf8");
            return Buffer.concat([head, change, tail]);
        };
        return edits.reduceRight(reduce, file.contents);
    };
    return Transformer;
})();
function formatOptions(options) {
    var defaults = DEFAULTS.options;
    var params = options;
    var result = {};
    Object.keys(defaults).forEach(function (key) {
        result[key] = params.hasOwnProperty(key) ? params[key] : defaults[key];
    });
    return result;
}
function scriptTarget(target) {
    if (!ts.ScriptTarget.hasOwnProperty(target)) {
        throw new gutil.PluginError(PLUGIN_NAME, target + " is not a valid script target");
    }
    return ts.ScriptTarget[target];
}
function format(params) {
    params = params || DEFAULTS;
    var options = params.options || DEFAULTS.options;
    var target = params.target || DEFAULTS.target;
    var transformer = new Transformer(formatOptions(options), scriptTarget(target));
    return through.obj(function (file, encoding, callback) {
        var stream = this;
        if (file.isStream()) {
            stream.emit("error", new gutil.PluginError(PLUGIN_NAME, "Streams are not supported"));
        }
        if (file.isBuffer()) {
            transformer.process(file);
        }
        stream.push(file);
        callback();
    });
}
module.exports = format;
